\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{lastpage}
\usepackage{pdfpages}
\usepackage{fancyvrb}
\usepackage[table]{colortbl}
\usepackage{fancyhdr}
\usepackage[margin=2.5 cm]{geometry}

\pagestyle{fancy}
\cfoot{Page \thepage\ of \pageref{LastPage}}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\author{Authors}
\title{Algorithms \& Networks \\ Exercise 1}
\lhead{Algorithms \& Networks}
\rhead{Exercise 1}

\begin{document}
\maketitle
\section{Strongly connected components and strongly connected graphs}
\subsection*{i}
Since v and w are mutually reachable then we have a path from v to w and a path from w to v. \\
Since w and x are mutually reachable then we have a path from w to x and a path from x to w.\\
For v and x to be mutually reachable we need:\\
\indent A path from v to x (1) \\ 
\indent A path from x to v (2) \\
We get (1) by using the path from v to w and then the path from w to x. \\
We get (2) by using the path from x to w and then the path from w to v.

\subsection*{ii}
Since X is the strongly connected component of v there is a path from v to w and also a path from w to v for all $w \in X$. That is, v and w are mutually reachable for all $w \in X$. By i) we then have that all pairs of vertices in X are mutually reachable so for all $w \in X$, X is at least a subset of the strongly connected component for w. \\
If there was a vertex that was in the strongly connected component of w but not in X then there would be a path from u to v and v to u and by i) u would then be in X which is a contradiction. \\
That means that X is exactly the strongly connected component of w.
\subsection*{iii}
1) Keep a list of visited vertices. \\
2) From v, visit all unvisited vertices, u, if there is an edge (v,u), and mark them as visited. \\
3) Repeat for newly visited vertices recursively until stops. \\
4) The desired set is the list of visited vertices\\
\\
This algorithm uses each edge and vertex at most once so it is $O(n + m)$.

\subsection*{iv}
Turn the direction of all arrows in A around and run iii)
\subsection*{v}
For any vertex $v \in V$ run both iii) and iv). If they both give V then the graph is strongly connected, otherwise not.
\subsection*{vi}
For a DAG you never have, for a pair of vertices, v and u, both a path from v to u and a path from u to v, so the strongly connected components are the vertices themselves, assuming that a vertex is strongly connected to itself.

\section{A stable marriage for Eric and Ariel?}
Suppose you can arrange things so that they are not matched. Then you have a mermaid, X, and a merman, Y, that give us the blocking pair (Y, Ariel) and (Eric, X) since Ariel prefers Eric over all others and therefore Y, and Eric prefers Ariel over all others and therefore X. \\
This contradicts the fact that the Gale-Shapley algorithm returns a stable matching, so they must be matched.

\section{Weak/strong stable marriages}
\subsection*{a) Strong instability}
If we break ties arbitrarily and run the Gale-Shapley algorithm we always find a stable matching where there is no strong instability. \\
\subsection*{b) Weak instability}
Any set of men and women that are completely indifferent to the matching will always have weak instabilities.\\
For example a set of two men and two women where both men and both women are indifferent to the other sex.

\section{Topological sort}
L $\leftarrow$ Empty list that will contain the sorted elements\\
S $\leftarrow$ Set of all nodes with no incoming edges\\
\textbf{while} S is non-empty \textbf{do}\\
\indent remove a node n from S\\
\indent add n to tail of L\\
\indent \textbf{for each }node m with an edge e from n to m \textbf{do}\\
\indent \indent remove edge e from the graph\\
\indent \indent \textbf{if} m has no other incoming edges \textbf{then}\\
\indent \indent \indent insert m into S\\
\textbf{if} graph has edges \textbf{then}\\
\indent \textbf{return} error (graph has at least one cycle)\\
\textbf{else} \\
\indent return L (a topologically sorted order)\\

There is always at least one node in S in the beginning since the graph is a DAG and
S is only empty when all the nodes have been moved to L. \\
While S is not empty each iteration of the while loop moves a node from S to L and L keeps a topological order since only nodes with no incoming edges are added to L and therefore a node can never be added before it's predecessor.\\
Finding the initial S is O(n), the while loop removes a node in every loop so it is goes n loops, and the for each loop goes in total once for each edge so it goes m loops in total. That means that the algorithm is O(n+m).


\section{Bonus question}

$M_1: anything $ \\
$M_2: W_1 > W_2 > W_3$\\
$M_2: W_2 > W_1 > W_3$\\\\
$W_1: M_3 > M_2 > M_1$\\
$W_2: M_2 > M_3 > M_1$\\
$W_3: anything$\\

0. Starting match: \\
$(M_1, W_1)$, $(M_2, W_2)$, $(M_3, W_3)$ \\
1. Swap for the blocking pair $M_2$ and $W_1$: \\
$(M_1, W_2)$, $(M_2, W_1)$, $(M_3, W_3)$ \\
2. Swap for the blocking pair $M_3$ and $W_1$ \\
$(M_1, W_2)$, $(M_2, W_3)$, $(M_3, W_1)$ \\
3. Swap for the blocking pair $M_3$ and $W_2$ \\
$(M_1, W_1)$, $(M_2, W_3)$, $(M_3, W_2)$ \\
4. Swap for the blocking pair $M_2$ and $W_2$ \\
$(M_1, W_1)$, $(M_2, W_2)$, $(M_3, W_3)$ \\
\\
We get the starting match so this is a loop that could go on forever.







\end{document}
